#pragma once

#include <cmath>
#include <bitset>
#include <string>
#include <vector>
#include <map>

#define POINT_LENGTH 5 // in metres
#define BITSET_CHUNK_SIZE 200 // in metres


const float point_length = POINT_LENGTH;
const float bitset_chunk_length = POINT_LENGTH * BITSET_CHUNK_SIZE; // in metres


enum class Exception;


struct Coordinates {
	double x;
	double y;

	Coordinates(double x, double y) : x(x), y(y) {}
};


enum class OccupyResult {
	Success = 0,
	Occupied,
	OutOfBounds,
};


/// <summary>
/// Represents a road on the grid.
/// A path starts from intersection, and may connect to multiple intersections, or none at all.
/// The initial intersection is where index 0 will refer to.
/// Positive offsets move away from that intersection.
/// </summary>
class Path {
public:
	/// <summary>
	/// Creates a new path.
	/// The path starts from the provided intersection.
	/// </summary>
	/// <param name="id">ID generated by the grid.</param>
	/// <param name="name">Name of the path.</param>
	/// <param name="length">Length of the path (multiples of <see cref="point_length" />)</param>
	/// <param name="number_of_lanes">Number of lanes (both ways) the path has.</param>
	/// <param name="starting_intersection">Pointer to the starting intersection.</param>
	Path(unsigned long id, std::string name, unsigned long length, unsigned int number_of_lanes, Intersection* starting_intersection);

	/// <summary>
	/// Tries to occupy the given point on the path.
	/// </summary>
	/// <param name="point">Index of the point to occupy on the path.</param>
	/// <returns>An OccupyResult variant indicating whether the operation succeeded.</returns>
	OccupyResult occupy(unsigned point);
	/// <summary>
	/// Resets the bit of the given index.
	/// The function does not check if the point was set.
	/// </summary>
	/// <param name="point">Index of the point to reset.</param>
	/// <returns>An OccupyResult variant indicating whether the operation succeeded. 'Occupied' variant will never be returned.</returns>
	OccupyResult release(unsigned point);
	/// <summary>
	/// Attempts to occupy the offset point. If that succeeds, the initial point is released.
	/// </summary>
	/// <param name="point">Index of the initial point.</param>
	/// <param name="offset">Offset from the initial point.</param>
	/// <returns>An OccupyResult variant indicating whether the operation succeeded.</returns>
	OccupyResult move(unsigned point, int offset);

	/// <returns>A constant reference to positions of connected intersections.</returns>
	const std::vector<int>& const get_intersections();
private:
	unsigned long m_id;
	std::string m_name;
	/// <summary>
	/// Length of the path in multiples of <see cref="point_length" />.
	/// </summary>
	unsigned long m_length;
	/// <summary>
	/// Number of lanes (both ways) the path has.
	/// </summary>
	unsigned int m_number_of_lanes;

	/// <summary>
	/// Vector of bitsets representing the occupied points on the path.
	/// All bitsets have the same size.
	/// Paths longer than the product of chunk size and point size will have additional bitsets in the vectors.
	/// </summary>
	std::vector<std::bitset<BITSET_CHUNK_SIZE>> m_occupied_points;
	/// <summary>
	/// Pointers to all intersections on the path.
	/// </summary>
	std::vector<Intersection*> m_intersections;
	/// <summary>
	/// Indices of the points in the path where the corresponding intersection exists.
	/// </summary>
	std::vector<int> m_intersection_points;
};

/// <summary>
/// A significant point on the grid.
/// All paths must start at an intersection.
/// An intersection can be connected to any number of points.
/// </summary>
class Intersection {
public:
	/// <summary>
	/// Constructs an intersection with the given coordinates.
	/// </summary>
	/// <param name="id">ID generated by the grid.</param>
	Intersection(unsigned long id, std::string name);

	/// <summary>
	/// Adds a path to the intersection.
	/// </summary>
	/// <param name="path">Pointer to path to connect.</param>
	void add_path(Path* path);
private:
	unsigned long m_id;
	std::string m_name;
	/// <summary>
	/// Pointers to connected paths.
	/// </summary>
	std::vector<Path*> m_paths;
};

/// <summary>
/// Represents the map of an area.
/// </summary>
class Grid {
public:
	Grid();

	/// <summary>
	/// Generate and add an intersection to the grid.
	/// </summary>
	unsigned long add_intersection(std::string name, double x, double y);
	/// <summary>
	/// Generate and add a path to the grid.
	/// </summary>
	unsigned long add_path(std::string name, unsigned long length, unsigned int number_of_lanes, unsigned long starting_intersection_id);
private:
	std::map<unsigned long, Intersection> m_intersections;
	std::map<unsigned long, Path> m_paths;
	std::map<unsigned long, Coordinates> m_intersection_locations;

	unsigned m_next_path_id;
	unsigned m_next_intersection_id;
};

/// <summary>
///  Represents a moving object (like a vehicle) that will occupy a point on the grid.
/// </summary>
class Entity {
public:
	/// <summary>
	/// Creates a new entity.
	/// The constructor throws an error (OccupyResult) if the position is already occupied or out of bounds.
	/// </summary>
	/// <param name="path">Pointer to the path the entity will start at</param>
	/// <param name="position">Index of point occupied on the path</param>
	Entity(Path* path, unsigned position);

	/// <summary>
	/// Moves the entity by the given displacement.
	/// </summary>
	/// <param name="distance">Offset from the current position</param>
	void move(int distance);
	/// <summary>
	/// Changes the path the entity is on.
	/// </summary>
	/// <param name="path">Pointer to the new path</param>
	void change_path(Path* path);
private:
	/// <summary>
	/// Pointer to the path the entity is currently on.
	/// </summary>
	Path* m_current_path;
	/// <summary>
	/// Index of the point occupied on the current path.
	/// </summary>
	unsigned m_position;
}